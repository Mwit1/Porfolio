---
title: JavaScript I wish I knew as a Juniour Developer
abstract:  A comprehensive list of important topics to learn in JavaScript
date: '2025-05-25'
banner: /static/modern-styling-in-react-banner.jpg
featured: true
---

I’ve spent a few years writing Javascript at various internships and learning  coding from online courses and YT videos. Over this time, I’ve learned what separates the Javascript pros from the novices/junior level developers. Not that im a pro.

My introduction to Javascript, things took a turn. I picked up the abstract and often confusing logic of this scripting language and sometimes simply didn’t. The Javascript ecosystem is also really large and hard to cover it in depth. But I luckily stambled upon a structured approach in learning [JS](https://roadmap.sh/javascript), [React](https://roadmap.sh/react), [Node.JS ](https://roadmap.sh/nodejs) you can check out the website I used.


---

## Events and Event Handling

**What:** Mechanism that allows you to run code when the user interacts with your page (clicks, scrolls, etc.).

**Why:** It makes your website interactive and responsive to user input.

```jsx
<button onClick={() => alert('Button Clicked!')}>Click Me</button>
```

**Example - Event Delegation:**
```jsx
<ul onClick={(e) => {
  if (e.target.tagName === 'LI') {
    alert(`You clicked ${e.target.textContent}`);
  }
}}>
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
```

---

## Closures

**What:** A closure is a function that remembers variables from its outer scope, even after that scope has finished executing.

**Why:** Useful for data privacy and partial application.
A closure is when a function “remembers” and continues to access variables from its lexical (surrounding) scope, even after that scope has finished executing.
Check this explanation on [Closures](https://www.youtube.com/watch?v=6Ixyltr8_R0)

```jsx
function counter() {
  let count = 0;
  return () => {
    count++;
    return count;
  };
}

const increment = counter();
console.log(increment()); // 1
console.log(increment()); // 2
```

---

## Event Loop
The [Event](https://www.youtube.com/watch?v=eiC58R16hb8) Loop is what makes asynchronous behavior in JavaScript possible, even though JS is single-threaded. It manages how and when code executes, especially asynchronous tasks like setTimeout , Promises, fetch(), DOM events

```jsx
console.log('Start');
setTimeout(() => console.log('Timeout'), 0);
Promise.resolve().then(() => console.log('Promise'));
console.log('End');
```

**Output:**
```
Start
End
Promise
Timeout
```

---

## Array and Object Methods

**Why:** These methods make manipulating data cleaner and more functional.

### Array Methods
```jsx
const nums = [1, 2, 3, 4];

const doubled = nums.map(n => n * 2); // [2, 4, 6, 8]
const evens = nums.filter(n => n % 2 === 0); // [2, 4]
const sum = nums.reduce((acc, n) => acc + n, 0); // 10
```

### Object Methods
```jsx
const person = { name: 'Edwin', age: 25 };

Object.keys(person); // ['name', 'age']
Object.values(person); // ['Edwin', 25]
Object.entries(person); // [['name', 'Edwin'], ['age', 25]]
```

---

## DOM Manipulation

**What:** Access and modify elements in the HTML.

**Why:** Enables dynamic UI changes.

```jsx
useEffect(() => {
  const el = document.getElementById('myDiv');
  el.style.color = 'blue';
}, []);

<div id="myDiv">Hello DOM</div>
```

---

## Asynchronous JavaScript

**What:** Ways to handle time-based or delayed operations.

**Why:** Prevents blocking the main thread.

### Promises
A Promise in JavaScript is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
JavaScript is single-threaded, so async tasks (like API calls, file reading, timers) can’t block the main thread. Promises help us manage asynchronous code in a clean, readable way — avoiding deeply nested callbacks (a.k.a. “callback hell”).
Check out this cool explanation of [Promises](https://www.youtube.com/watch?v=Xs1EMmBLpn4)
```jsx
fetch('https://api.example.com')
  .then(res => res.json())
  .then(data => console.log(data));
```

### Async/Await
```jsx
async function loadData() {
  const res = await fetch('https://api.example.com');
  const data = await res.json();
  console.log(data);
}
```

---

## Object-Oriented Programming (OOP)

**What:** A paradigm based on objects and classes.

**Why:** Promotes code reuse, encapsulation, and structure.

```jsx
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

---

## Functional Programming (FP)

**What:** Programming using pure functions and avoiding shared state.

**Why:** Easier to test, debug, and maintain.

```jsx
const add = x => y => x + y; // Currying

const result = add(2)(3); // 5
```

**Immutability Example:**
```jsx
const numbers = [1, 2, 3];
const newNumbers = [...numbers, 4]; // [1, 2, 3, 4]
```

---

## APIs and Modules

**What:** Ways to fetch data (APIs) and organize code (Modules).

**Why:** Separates concerns and enables clean architecture.

### API Fetch Example
```jsx
useEffect(() => {
  const fetchData = async () => {
    const res = await fetch('/api/data');
    const data = await res.json();
    console.log(data);
  };
  fetchData();
}, []);
```

### Modules Example
```js
// math.js
export const add = (a, b) => a + b;

// app.js
import { add } from './math.js';
console.log(add(2, 3)); // 5
```

---